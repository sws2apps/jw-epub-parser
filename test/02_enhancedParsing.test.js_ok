import fs from 'fs';
import * as path from 'path';
import fetch from 'node-fetch';
import { expect } from 'chai';
import { loadEPUB } from '../dist/node/index.js';

const list = JSON.parse(await fs.promises.readFile(new URL('./enhancedParsing/list.json', import.meta.url)));

const JW_CDN = 'https://app.jw-cdn.org/apis/pub-media/GETPUBMEDIALINKS?';
const JW_FINDER = 'https://www.jw.org/finder?';

const fetchIssueData = async (issue, pub) => {
  try {
    if (issue.hasEPUB) {
      const epubFile = issue.hasEPUB[0].file;
      const epubUrl = epubFile.url;

      const epubData = await loadEPUB({ url: epubUrl });
      return epubData;
    }

    if (!issue.hasEPUB) {
      const language = issue.language;

      const url =
        JW_FINDER +
        new URLSearchParams({
          wtlocale: language,
          pub,
          issue: issue.issueDate,
        });

      const res = await fetch(url);
      const result = await res.text();

      const parser = new window.DOMParser();
      const htmlItem = parser.parseFromString(result, 'text/html');

      if (pub === 'mwb') {
        const docIds = [];
        const accordionItems = htmlItem.getElementsByClassName(`docClass-106 iss-${issue.issueDate}`);
        for (const weekLink of accordionItems) {
          weekLink.classList.forEach((item) => {
            if (item.indexOf('docId-') !== -1) {
              docIds.push(item.split('-')[1]);
            }
          });
        }

        const htmlRaws = [];

        const fetchSchedule1 = fetch(`https://www.jw.org/finder?wtlocale=${language}&docid=${docIds[0]}`).then((res) =>
          res.text()
        );
        const fetchSchedule2 = fetch(`https://www.jw.org/finder?wtlocale=${language}&docid=${docIds[1]}`).then((res) =>
          res.text()
        );
        const fetchSchedule3 = fetch(`https://www.jw.org/finder?wtlocale=${language}&docid=${docIds[2]}`).then((res) =>
          res.text()
        );
        const fetchSchedule4 = fetch(`https://www.jw.org/finder?wtlocale=${language}&docid=${docIds[3]}`).then((res) =>
          res.text()
        );
        const fetchSchedule5 = fetch(`https://www.jw.org/finder?wtlocale=${language}&docid=${docIds[4]}`).then((res) =>
          res.text()
        );
        const fetchSchedule6 = fetch(`https://www.jw.org/finder?wtlocale=${language}&docid=${docIds[5]}`).then((res) =>
          res.text()
        );
        const fetchSchedule7 = fetch(`https://www.jw.org/finder?wtlocale=${language}&docid=${docIds[6]}`).then((res) =>
          res.text()
        );
        const fetchSchedule8 = docIds[7]
          ? fetch(`https://www.jw.org/finder?wtlocale=${language}&docid=${docIds[7]}`).then((res) => res.text())
          : Promise.resolve('');
        const fetchSchedule9 = docIds[8]
          ? fetch(`https://www.jw.org/finder?wtlocale=${language}&docid=${docIds[8]}`).then((res) => res.text())
          : Promise.resolve('');
        const fetchSchedule10 = docIds[9]
          ? fetch(`https://www.jw.org/finder?wtlocale=${language}&docid=${docIds[9]}`).then((res) => res.text())
          : Promise.resolve('');

        const raws = await Promise.all([
          fetchSchedule1,
          fetchSchedule2,
          fetchSchedule3,
          fetchSchedule4,
          fetchSchedule5,
          fetchSchedule6,
          fetchSchedule7,
          fetchSchedule8,
          fetchSchedule9,
          fetchSchedule10,
        ]);

        for (let z = 0; z < raws.length; z++) {
          const rawText = raws[z];
          if (rawText !== '') {
            htmlRaws.push(rawText);
          }
        }

        const epubData = await loadEPUB({ htmlRaws, epubYear: issue.currentYear, epubLang: language, isMWB: true });
        return epubData;
      }

      if (pub === 'w') {
        const docIds = [];
        const accordionItems = htmlItem.getElementsByClassName(`docClass-40 iss-${issue.issueDate}`);
        for (const weekLink of accordionItems) {
          weekLink.classList.forEach((item) => {
            if (item.indexOf('docId-') !== -1) {
              docIds.push(item.split('-')[1]);
            }
          });
        }

        const htmlArticles = [];

        const fetchArticle1 = fetch(`https://www.jw.org/finder?wtlocale=${language}&docid=${docIds[0]}`).then((res) =>
          res.text()
        );
        const fetchArticle2 = fetch(`https://www.jw.org/finder?wtlocale=${language}&docid=${docIds[1]}`).then((res) =>
          res.text()
        );
        const fetchArticle3 = fetch(`https://www.jw.org/finder?wtlocale=${language}&docid=${docIds[2]}`).then((res) =>
          res.text()
        );
        const fetchArticle4 = fetch(`https://www.jw.org/finder?wtlocale=${language}&docid=${docIds[3]}`).then((res) =>
          res.text()
        );
        const fetchArticle5 = fetch(`https://www.jw.org/finder?wtlocale=${language}&docid=${docIds[4]}`).then((res) =>
          res.text()
        );

        const raws = await Promise.all([fetchArticle1, fetchArticle2, fetchArticle3, fetchArticle4, fetchArticle5]);

        for (let z = 0; z < raws.length; z++) {
          const rawText = raws[z];
          if (rawText !== '') {
            htmlArticles.push({ docid: docIds[z], htmlRaw: rawText });
          }
        }

        const epubData = await loadEPUB({
          htmlRaws: [result],
          epubYear: issue.currentYear,
          epubLang: language,
          isW: true,
          htmlArticles,
        });

        return epubData;
      }
    }
  } catch (err) {
    throw new Error(err);
  }
};

const fetchData = async (language, issue, pub) => {
  let data = [];
  let fixture = [];

  const url =
    JW_CDN +
    new URLSearchParams({
      langwritten: language,
      pub,
      output: 'json',
      issue,
    });

  const res = await fetch(url);

  if (res.status === 200) {
    const result = await res.json();
    const hasEPUB = result.files[language].EPUB;

    const issueFetch = { issueDate: issue, currentYear: issue.substring(0, 4), language, hasEPUB: hasEPUB };

    data = await fetchIssueData(issueFetch, pub);

    if (hasEPUB) {
      const epubFile = hasEPUB[0].file;
      const epubUrl = epubFile.url;
      const epubName = path.basename(epubUrl);
      fixture = (await import(`./fixtures/${epubName.replace('.epub', '.js')}`)).default;
    }

    if (!hasEPUB) {
      fixture = (await import(`./fixtures/${pub}_${language}_${issue}.js`)).default;
    }
  }

  return { data, fixture };
};

describe('Testing Enhanced Parsing', async () => {
  for (let i = 0; i < list.length; i++) {
    const { language, issue } = list[i];

    describe(`Test loadEPUB function for ${language} language`, async () => {
      it(`Parsing Meeting Workbook EPUB file`, async () => {
        const { data, fixture } = await fetchData(language, issue, 'mwb');

        for (let a = 0; a < fixture.length; a++) {
          const week = fixture[a];
          for (let [key, value] of Object.entries(week)) {
            expect(data[a]).to.have.property(key).equal(value);
          }
        }
      });

      it(`Parsing Watchtower Study EPUB file`, async () => {
        const { data, fixture } = await fetchData(language, issue, 'w');

        for (let a = 0; a < fixture.length; a++) {
          const week = fixture[a];
          for (let [key, value] of Object.entries(week)) {
            expect(data[a]).to.have.property(key).equal(value);
          }
        }
      });
    });
  }
});
